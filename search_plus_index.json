{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction 有关于最近学习踩坑的记录 "},"gitbook/gitbook.html":{"url":"gitbook/gitbook.html","title":"gitbook","keywords":"","body":"安装 安装Node.js 安装gitbook 插件 simple-page-toc 生成本页目录 Search Plus 安装Node.js 推荐v10.21.0版本的nodejs下载: 与gitbook完美兼容 https://blog.csdn.net/Lowerce/article/details/107579261 查看源 npm get registry 更换源 npm config set registry http://registry.npm.taobao.org 安装gitbook npm install gitbook-cli -g 初始化gitbook项目 gitbook init 会生成README.md SUMMARY.md SUMMARY是目录吗，按着添加文档就行 部署服务 gitbook build 部署服务会默认build一下，build会自动生成对应的js,html文件 gitbook serve 参考: https://zhuanlan.zhihu.com/p/34946169 插件 插件只要在book.json添加插件然后 gitbook install 安装一下即可(速度有点慢)或者使用npm安装 simple-page-toc 生成本页目录 npm install gitbook-plugin-simple-page-toc { \"plugins\" : [ \"simple-page-toc\" ], \"pluginsConfig\": { \"simple-page-toc\": { \"maxDepth\": 3, \"skipFirstH1\": true } } } 参数 说明 \"maxDepth\": 3 使用深度最多为maxdepth的标题。 \"skipFirstH1\": true 排除文件中的第一个h1级标题。 使用方法: 在需要生成目录的地方用跟top跟endtop的标签括起来，全文都生成的话就在首尾添加 Search Plus 支持中文搜索, 需要将默认的 search 和 lunr 插件去掉。 { \"plugins\": [\"-lunr\", \"-search\", \"search-plus\"] } "},"readCode/readCode.html":{"url":"readCode/readCode.html","title":"源码阅读","keywords":"","body":"源码阅读(Base1.8) HashMap ConcurrentHashMap "},"readCode/HashMap.html":{"url":"readCode/HashMap.html","title":"HashMap","keywords":"","body":"ConcurrentHashMap 1.继承关系 2.几个变量 3.put 3.1.treeifyBin() 3.2.TreeNode.treeify 3.3.TreeNode.putTreeVal( 4.get 4.1.TreeNode.getTreeNode 1.继承关系 继承自 AbstractMap ,实现了 Map 接口,但是其实有点奇怪的是，明明它们的方法都是一样的，在stackoverflow找到了答案（点击这里跳转） public class HashMap extends AbstractMap implements Map, Cloneable, Serializable{} 2.几个变量 // 默认容量，容量必须是2的幂 static final int DEFAULT_INITIAL_CAPACITY = 1 Capacity*load_factor时进行扩容 static final float DEFAULT_LOAD_FACTOR = 0.75f; // 桶转换为树的阈值 static final int TREEIFY_THRESHOLD = 8; // 转换为桶的阈值 static final int UNTREEIFY_THRESHOLD = 6; // 树化容量阈值。为了避免进行扩容、树形化选择的冲突，这个值不能小于 4 * TREEIFY_THRESHOLD static final int MIN_TREEIFY_CAPACITY = 64; 3.put 像 afterNode*** 这种方法都是为LinkedHashMap预留的，HashMap里的实现都是空的 /** * Implements Map.put and related methods. * * @param hash hash for key * @param key the key * @param value the value to put * @param onlyIfAbsent 为true 不改变现有值 * @param evict flase 是创建模式 * @return previous value, or null if none */ final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node[] tab; Node p; int n, i; // 如果数组为空，就初始化一下，n是数组长度 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 如果key hash值的链表头结点是空，那么新建一个 if ((p = tab[i = (n - 1) & hash]) == null) tab[i] = newNode(hash, key, value, null); else { Node e; K k; // 如果这是个链表并且key不为空，且头结点p等于传入的key值 if (p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k)))) e = p; // 否则 p 是个红黑树，使用红黑树putval else if (p instanceof TreeNode) e = ((TreeNode)p).putTreeVal(this, tab, hash, key, value); else { // 到这里说明是链表但不是头结点，那就循环找key相等的节点，binCount记录的是链表长度 for (int binCount = 0; ; ++binCount) { // 找到结尾都还没找到，那就新加一个节点 if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); // 链表长度再长就要到阈值了，得转换成树 if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k)))) break; // 跟e = p.next配合，链表向后遍历 p = e; } } // 当找到的节点不为空是，看是否需要替换当前值 if (e != null) { // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } // 操作数+1，据此判断是否有并发操作风险 ++modCount; if (++size > threshold) resize(); afterNodeInsertion(evict); return null; } 其中值得注意的是treeifyBin()方法，将链表转换为红黑树，需要再详细了解 TreeNode.putTreeVal()看一下实现 3.1.treeifyBin() /** * Replaces all linked nodes in bin at index for given hash unless * table is too small, in which case resizes instead. */ final void treeifyBin(Node[] tab, int hash) { int n, index; Node e; // 如果数组为空或者数组没到成树条件，只扩容大小 if (tab == null || (n = tab.length) hd = null, tl = null; do { TreeNode p = replacementTreeNode(e, null); if (tl == null) hd = p; // 其实操作下来就是把整个链表转换为了TreeNode的双向链表 else { p.prev = tl; tl.next = p; } tl = p; } while ((e = e.next) != null); // 到这里我们发现，其实还没转换成红黑树，继续看treeify函数 if ((tab[index] = hd) != null) hd.treeify(tab); } } 3.2.TreeNode.treeify 复习红黑树之后补充 3.3.TreeNode.putTreeVal( 复习红黑树之后补充 4.get get方法比较简单，只要找不到返回null就完事了，而且不涉及数据结构的变更 public V get(Object key) { Node e; return (e = getNode(hash(key), key)) == null ? null : e.value; } /** * Implements Map.get and related methods. * * @param hash hash for key * @param key the key * @return the node, or null if none */ final Node getNode(int hash, Object key) { Node[] tab; Node first, e; int n; K k; // 当时数组不为空，且长度>0s时候，并且hash取模有元素 if ((tab = table) != null && (n = tab.length) > 0 && (first = tab[(n - 1) & hash]) != null) { //要是第一个直接返回第一个节点 if (first.hash == hash && // always check first node ((k = first.key) == key || (key != null && key.equals(k)))) return first; // 有后续节点不为空 if ((e = first.next) != null) { // 要是第一个节点是树节点，就从树节点里取 if (first instanceof TreeNode) return ((TreeNode)first).getTreeNode(hash, key); // 链表的话就循环遍历，没有那只能返回null了 do { if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k)))) return e; } while ((e = e.next) != null); } } return null; } 4.1.TreeNode.getTreeNode 红黑树作为一颗平衡二叉树，我们很容易根据hash值的大小来搜索指定的节点，没有则返回null /** * Finds the node starting at root p with the given hash and key. * The kc argument caches comparableClassFor(key) upon first use * comparing keys. */ final TreeNode find(int h, Object k, Class kc) { TreeNode p = this; do { int ph, dir; K pk; TreeNode pl = p.left, pr = p.right, q; // 小于走左子树，大于走右子树，等于直接返回当前节点 if ((ph = p.hash) > h) p = pl; else if (ph getTreeNode(int h, Object k) { return ((parent != null) ? root() : this).find(h, k, null); } "},"readCode/ConcurrentHashMap.html":{"url":"readCode/ConcurrentHashMap.html","title":"ConcurrentHashMap","keywords":"","body":"ConcurrentHashMap 1.继承关系 2.put 3.get 1.继承关系 跟 map 一样，继承自 AbstractMap ,但是实现的 ConcurrentMap 接口，ConcurrentMap与Map接口区别主要在于是否允许null值，以及对于并发的操作是否抛出 ConcurrentModificationException 异常，以及保障一些操作（compute，merge）的原子性 public class ConcurrentHashMap extends AbstractMap implements ConcurrentMap, Serializable{} 2.put /** Implementation for put and putIfAbsent */ final V putVal(K key, V value, boolean onlyIfAbsent) { // key跟value都不允许空值 if (key == null || value == null) throw new NullPointerException(); // 计算Hash值 int hash = spread(key.hashCode()); // 记录链表长度 int binCount = 0; for (Node[] tab = table;;) { Node f; int n, i, fh; // 如果数组长度为空，进行初始化 if (tab == null || (n = tab.length) == 0) tab = initTable(); // 获取链表的第一个元素，为空则新建 else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) { if (casTabAt(tab, i, null, new Node(hash, key, value, null))) break; // no lock when adding to empty bin } // 如果f的Hash等于MOVED则扩容 else if ((fh = f.hash) == MOVED) tab = helpTransfer(tab, f); // 如果头结点不为空，加锁 else { V oldVal = null; synchronized (f) { if (tabAt(tab, i) == f) { // 头结点hash>0为链表 if (fh >= 0) { binCount = 1; for (Node e = f;; ++binCount) { K ek; if (e.hash == hash && ((ek = e.key) == key || (ek != null && key.equals(ek)))) { oldVal = e.val; if (!onlyIfAbsent) e.val = value; break; } Node pred = e; if ((e = e.next) == null) { pred.next = new Node(hash, key, value, null); break; } } } // 要是为Treebin，那就是红黑树 else if (f instanceof TreeBin) { Node p; binCount = 2; if ((p = ((TreeBin)f).putTreeVal(hash, key, value)) != null) { oldVal = p.val; if (!onlyIfAbsent) p.val = value; } } } } if (binCount != 0) { // 链表长度大于阈值，转化为树 if (binCount >= TREEIFY_THRESHOLD) treeifyBin(tab, i); if (oldVal != null) return oldVal; break; } } } addCount(1L, binCount); return null; } 3.get "},"DataStructure/":{"url":"DataStructure/","title":"数据结构及算法","keywords":"","body":"Introduction 有关于最近学习踩坑的记录 "},"DataStructure/RedBlackTree.html":{"url":"DataStructure/RedBlackTree.html","title":"红黑树","keywords":"","body":""}}